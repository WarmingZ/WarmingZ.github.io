I"›;<p>In the last post, I described the work of simple server requests to the database. A minimal set of theories for understanding what we are dealing with was also described. Considered simple SELECT queries where we filtered data using WHERE. In this post, I would like to demonstrate the use of simple and aggregate functions. Maybe now it seems to you that everything is very easy, but so it is. It is true that we have not yet made any changes to our tables and created new ones, but this is just the beginning üòä.</p>

<center>
<img src="/img/posts/Database2/DB.png" alt="Network" class="responsive" style="width: 65%; height: auto;" />
</center>

<hr />

<h3 id="using-simple-functions">Using simple functions</h3>

<p>First of all, I would like to say that SQL has many built-in functions to perform various tasks. I would like to demonstrate the most commonly used functions. Also, if you need to write a specific request and you do not have enough features to be covered in this article, you can always visit the official documentation.
Also, because there are so many examples to choose from, I chose only the most interesting ones, in my opinion, to move faster and not overload with information. Maybe I can‚Äôt write short yet, but I‚Äôm learning üôÑ.</p>

<h4 id="if-functionÔ∏è"><code class="language-plaintext highlighter-rouge">IF</code> function‚öôÔ∏è</h4>

<p>So, in the table <code class="language-plaintext highlighter-rouge">discussion_group</code> we have a cell<code class="language-plaintext highlighter-rouge"> approve_required</code>, which stores user registration confirmations in the form of zeros and ones. And we need to get users out. To do this, we will use the operator <code class="language-plaintext highlighter-rouge">if</code>.</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="n">if</span><span class="p">(</span><span class="n">approve_required</span><span class="p">,</span> <span class="s1">'required'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span> 
<span class="n">approve_required</span> <span class="k">from</span> <span class="n">discussion_group</span><span class="p">;</span></code></pre></figure>

<p>Here is the result of the query:</p>

<table class="table table-responsive">
  <thead>
    <tr>
      <th style="text-align: center">if(approve_required, ‚Äòrequired‚Äô, ‚Äò‚Äô)</th>
      <th>approve_required from</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">required</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">¬†</td>
      <td>0</td>
    </tr>
    <tr>
      <td style="text-align: center">required</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">required</td>
      <td>1</td>
    </tr>
    <tr>
      <td style="text-align: center">¬†</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>We see that our function is displayed in the column name. We can change this to normal with the <code class="language-plaintext highlighter-rouge">as</code> operator.</p>

<p>Also, in the next example, we will go to the column <code class="language-plaintext highlighter-rouge">disscusion_group</code>, where we will define the old and new groups. The query will look like this: <br /></p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> <span class="k">select</span> <span class="n">group_id</span> <span class="k">as</span> <span class="n">ID</span> <span class="p">,</span> <span class="n">creation_time</span> <span class="k">as</span> <span class="n">CreationData</span> <span class="p">,</span>
  <span class="n">if</span><span class="p">(</span><span class="n">creation_time</span> <span class="o">&gt;</span> <span class="s1">'2020-01-01'</span><span class="p">,</span> <span class="s1">'new'</span><span class="p">,</span> <span class="s1">'old'</span><span class="p">)</span>
  <span class="k">as</span> <span class="k">Type</span> <span class="k">from</span> <span class="n">discussion_group</span><span class="p">;</span></code></pre></figure>

<p>If the creation date is greater than <code class="language-plaintext highlighter-rouge">2020.01.01</code> it is new, otherwise - old. Here is the result:</p>

<table class="table table-responsive">
  <thead>
    <tr>
      <th>ID</th>
      <th style="text-align: center">CreationData</th>
      <th style="text-align: center">Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>570779</td>
      <td style="text-align: center">2018-12-21 00:39:04</td>
      <td style="text-align: center">old</td>
    </tr>
    <tr>
      <td>570890</td>
      <td style="text-align: center">2019-12-25 00:40:09</td>
      <td style="text-align: center">old</td>
    </tr>
    <tr>
      <td>570853</td>
      <td style="text-align: center">2019-12-29 00:39:04</td>
      <td style="text-align: center">old</td>
    </tr>
    <tr>
      <td>570863</td>
      <td style="text-align: center">2020-05-17 00:39:05</td>
      <td style="text-align: center">new</td>
    </tr>
    <tr>
      <td>570922</td>
      <td style="text-align: center">2021-01-13 00:39:04</td>
      <td style="text-align: center">new</td>
    </tr>
    <tr>
      <td>570888</td>
      <td style="text-align: center">2021-03-02 00:39:04</td>
      <td style="text-align: center">new</td>
    </tr>
  </tbody>
</table>
<p>As you can see from the request, we renamed our cells to normal.</p>

<h4 id="coalesce-functionÔ∏è"><code class="language-plaintext highlighter-rouge">COALESCE</code> function‚öôÔ∏è</h4>

<p>The SQL language has functions such as <code class="language-plaintext highlighter-rouge">COALESCE</code> and<code class="language-plaintext highlighter-rouge"> ISNULL</code>, which check the input parameters of <code class="language-plaintext highlighter-rouge">NULL</code>.</p>

<p>We receive messages from the table <code class="language-plaintext highlighter-rouge">user_private_message</code>, which were read after a certain date. But not all messages have a read date, so we will use the reference date for unread messages and will use this date in the condition. Here we can use the <code class="language-plaintext highlighter-rouge">coalesce</code> function in<code class="language-plaintext highlighter-rouge"> where</code> conditions.</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> <span class="k">Select</span> <span class="n">message_id</span><span class="p">,</span> <span class="n">user_from_id</span><span class="p">,</span>
  <span class="n">user_to_id</span> <span class="k">from</span> <span class="n">user_private_message</span>
  <span class="k">where</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">read_time</span><span class="p">,</span> <span class="n">send_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="s1">'2020-10-20'</span><span class="p">;</span></code></pre></figure>

<p>Here is the result of the query:</p>

<table class="table table-responsive">
  <thead>
    <tr>
      <th style="text-align: center">message_id</th>
      <th style="text-align: center">user_from_id</th>
      <th style="text-align: center">user_to_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">6521171</td>
      <td style="text-align: center">8425</td>
      <td style="text-align: center">7838</td>
    </tr>
    <tr>
      <td style="text-align: center">6521181</td>
      <td style="text-align: center">8144</td>
      <td style="text-align: center">8328</td>
    </tr>
    <tr>
      <td style="text-align: center">6521186</td>
      <td style="text-align: center">7614</td>
      <td style="text-align: center">7720</td>
    </tr>
    <tr>
      <td style="text-align: center">6521190</td>
      <td style="text-align: center">7960</td>
      <td style="text-align: center">7817</td>
    </tr>
    <tr>
      <td style="text-align: center">6521200</td>
      <td style="text-align: center">7683</td>
      <td style="text-align: center">8163</td>
    </tr>
    <tr>
      <td style="text-align: center">6521207</td>
      <td style="text-align: center">7490</td>
      <td style="text-align: center">8533</td>
    </tr>
  </tbody>
</table>
<p>I think everything is clear here. Let‚Äôs move on to the CONCAT functions.</p>

<h4 id="concat-functionÔ∏è"><code class="language-plaintext highlighter-rouge">CONCAT</code> function‚öôÔ∏è</h4>

<p>This feature helps to glue cells. For example, we can glue the cell <code class="language-plaintext highlighter-rouge">firstname</code> and<code class="language-plaintext highlighter-rouge"> lastname</code> - creating the following query:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> <span class="k">select</span> <span class="n">concat</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="s1">' '</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">Name</span> <span class="k">from</span> <span class="k">user</span><span class="p">;</span> </code></pre></figure>

<p>And get the following result:</p>

<table class="table table-responsive">
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Carla Mariet</td>
    </tr>
    <tr>
      <td style="text-align: center">Sophy Brags</td>
    </tr>
    <tr>
      <td style="text-align: center">Ivan Soloviov</td>
    </tr>
    <tr>
      <td style="text-align: center">Doug Anne marie</td>
    </tr>
  </tbody>
</table>

<p>I think everything is clear here and we can move on to our aggregate functions.</p>

<hr />

<h2 id="aggregate-sql-functions">Aggregate SQL functions</h2>

<p>First of all, SQL aggregate functions act on column values in order to obtain a single resulting value.
Consider aggregate functions on the example of <code class="language-plaintext highlighter-rouge">COUNT</code>.</p>

<h4 id="count-function"><code class="language-plaintext highlighter-rouge">COUNT</code> functionüî©</h4>

<p>In this example, let‚Äôs count how many messages we have sent and how many of them have been read. We will do this with the following query:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">user_private_message</span> 
  <span class="k">where</span> <span class="n">read_time</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span> <span class="p">;</span></code></pre></figure>

<p>Here we have counted how many messages have been sent and read. That is, we counted only those columns in which there is no <code class="language-plaintext highlighter-rouge">null</code>, in the table<code class="language-plaintext highlighter-rouge"> user_private_message</code>. First we send the cell <code class="language-plaintext highlighter-rouge">from user_private_message</code> and then we filter it (<code class="language-plaintext highlighter-rouge"> where read_time is not null</code>) and send it to our <code class="language-plaintext highlighter-rouge">count (*)</code>.
In this case, when we use an asterisk, we select all the cells and load them into memory.
Now if we pass instead of an asterisk, a parameter, the request will look like this:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">read_time</span><span class="p">)</span> <span class="k">from</span> <span class="n">user_private_message</span><span class="p">;</span></code></pre></figure>

<p>That is, we can estimate how much more compact our request has become. <br />
üí° <strong>Also worth remembering! Many programmers use such an optimization ‚Äúchip‚Äù, passing in <code class="language-plaintext highlighter-rouge">count (1)</code> unit. That is, when choosing from a table, we do not use intermediate memory, just for each cell we perform a function <code class="language-plaintext highlighter-rouge">count (1)</code>, which does not require any values (it just adds +1 to some aggregate value). Thus, we do not use the buffer to store values that we are not even going to return from the database.</strong></p>

<p>There are also such functions as: <code class="language-plaintext highlighter-rouge">Average</code>,<code class="language-plaintext highlighter-rouge"> Min</code>, <code class="language-plaintext highlighter-rouge">Max</code>,<code class="language-plaintext highlighter-rouge"> Sum</code>. I will not describe these functions, because their name is clear. You can easily find them online. I apologize for this, but if we paint each function, we will never go to the most interesting and complex functionsüòâ.</p>

<h4 id="cast-function"><code class="language-plaintext highlighter-rouge">CAST</code> functionüî©</h4>

<p>And finally, let‚Äôs consider just an interesting function <code class="language-plaintext highlighter-rouge">CAST</code>. This function allows you to convert an expression from one data type to another and it is not aggregate. Click on me <a href="https://docs.microsoft.com/ru-ru/sql/t-sql/functions/cast-and-convert-transact-sql?view=sql-server-ver15"><code class="language-plaintext highlighter-rouge">CAST</code></a>, if you want to know more about the function and the arguments it can take.</p>

<p>In many old databases, the year was written in only two digits. With the help of cast, we can convert that data into a new format.</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> <span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="k">cast</span><span class="p">(</span><span class="nv">"21"</span><span class="k">as</span> <span class="nb">year</span><span class="p">);</span></code></pre></figure>

<p>And get the following answer to our request:</p>

<table class="table table-responsive">
  <thead>
    <tr>
      <th style="text-align: center">cast(‚Äú21‚Äùas year)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">2021</td>
    </tr>
  </tbody>
</table>

<p>So far, we have considered only one aggregate function, which I found quite interesting. If you want to know more about them, follow this <a href="https://www.sqlservertutorial.net/sql-server-aggregate-functions/">link</a>.</p>

<hr />

<p>So, this post may seem a bit confusing, but I advise you to reproduce all the queries that have been made in this post. This will help you better understand how these queries work. Experiment and use the documentation, but be careful. Because if you installed SQL Server according to my example (<a href="https://www.soloviov.fun/sql/tech/translated/SQL-for-the-programmer-ua/">from the previous article</a>), you can break the server since we work as a <code class="language-plaintext highlighter-rouge">root</code> user with unlimited access rights on the server. See you in the next postüëãüòâ.</p>
:ET